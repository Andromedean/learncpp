notes on the Go language: a personal reference not a guide

packages
    every program is made of packages
    programs start running from the main package
    by convention, the package name is the same as the last element of the import path
exported names
    a member is exported when its name starts with a capitalized letter
    only exported names are available from imported packages
factored blocks
    import (
        "fmt"
        "net"
    )
functions
parameters
    func <funcName>(<arg0> <arg0Type>, ...) {}
    parameters with the same type may omit the type on all but the last arg
return results
    may return any number of values
named return values
    may name return values and use them as declared variables
    "naked return" automatically returns the values if named (only use in short funcs)
    func split(sum int) (x, y int) {
    	x = sum * 4 / 9
    	y = sum - x
    	return
    }
variables
    var <name0> <type0>, <name1> <type1>, ... = <initializer1>, ...
    may omit type (if same) until last variable
    type may be ommitted if initializer present
    may be package or function level
    <name> := <initializer> // shorthand can use within functions
        outside of a func, every statement begins with a keyword
    may factored into blocks like with imports
types
    ---
    bool
    string
    int  int8  int16  int32  int64
    uint uint8 uint16 uint32 uint64 uintptr
    byte // alias for uint8
    rune // alias for int32
         // represents a Unicode code point
    float32 float64
    complex64 complex128
    ---
    int, uint, uintptr are usually size n for n-bit systems
    Printf(): %T will print type of the var provided
zero values
    variables declared without an explicit initial value are given their zero value
    numeric     0
    bool        false
    string      "" (empty string)
    pointer     nil
type conversion
    type(<var>)
    explicitely required when an assignment has different types
constants
    const <name> = <value>
numeric constants
    are values and take on a type best for the sitution it is used in
for
    the only looping construct
    for <init>; <condition>; <post> {
    } // for
    init, and post are optional: exclude them and the semicolons for a while loop
while
    for <condition> {}
forever
    for {}
if
    if <optional_init;> <condition> {}
switch
    switch <init;> <variable> {
        case <>:
        case <>:
        default:
    } // switch
    cases need not be constants or ints
        may be values, vars, expressions
    cases do not fallthrough unless 'fallthrough' statement
        ie implicit break
    cases are evaluated top-to-bottom and stop executing once one succeeds
    may use switch {} to condense long if-else chains
defer
    defer <func()>
    defer func() { <statements> }()
    runs at func's return in last-in-first-out order (stack)
    deferred func's args are evaluated immediately though
    deferred functions may read and assign to the returning function's named return values
        executes after the surrounding statement returns
        eg: returns 2
        func c() (i int) {
            defer func() { i++ }()
            return 1
        } // c()
panic()
    stops execution of the current func, deferred funcs are executed, the current func returns
    causes the current func's surrounding func to panic as well
        propogates up the stack all funcs in the current goroutine have returned then crashes
    Go convention is that packages in libs using panic still presents explicit error ret val
recover()
    regains control of a panicking goroutine
    only useful inside a defferred func
pointer
    var <name> *<type>
    *<var> dereference/indirect
    &<var> generates a pointer
    no pointer arithmetic
struct
    collection of fields
    type <name> struct {
        <fieldi> <typei>
    }
    initializing
        s := <name>{<vali>}
        s := <structName>{<Fieldi>: <val>} // to init a subset of fields
    fields accessed using .
        s.Fieldi
    *struct pointer
        may use structPtr.Field without explicitely dereferencing
arrays
    [n]T    an n-valued array of type T
    arr := [n]T{1, 2, ... , n}
    length is part of the type so arrays cannot be resized
slices
    []T             a slice with elements of type T
    arr[low:high]   [low,high)
    dynamically sized flexible view into elements of an array
    make
        make([]T, <len>)
        make([]T, <len>, <cap>)
        allocates a zeroed array and returns a slice refering to that array
    changing elements of a slice changes the elements of the array
    may omit high and or low bounds which default to len and 0 
    len(s): elements in the slice
    cap(s): elements in the underlying array counting from the first of the slice
    slice literal
        []T{1, 2, ... , n}
        creates an array then builds a slice that references it
    zero value of nil
        has len(s) and cap(s) of 0 and no underlying array
    slices may contain other slices
        sliceOfSlices := [][]T{
            []T{...},
            ...     
        }
    appending
        append(s []T, vs ...T)
        a slice and variable length of parameters of type T to append
        if the backing array is too small, a new array will be allocated
            the returned slice will refer to the new array
range form of a for loop
    for <index>, <copyOfElement> := range <slice/map> {
        ... 
    } // for
    iterates over a slice or a map
    may skip index or copyOfElement by replacing with '_'
    for _, <e> := range ...
    for <i>, _ := range ...
    for <i> := range ...
        or just omit e if only wanting i
